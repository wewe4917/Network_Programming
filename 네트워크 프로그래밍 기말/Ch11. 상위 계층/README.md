# 네트워크 프로그래밍 기말정리
## 상위 계층
### > OSI 7 계층 vs 인터넷 계층 모델
![image](https://user-images.githubusercontent.com/85292541/206719013-f84b4769-dc17-4037-ab71-e5ac3b2095f1.png)
- 인터넷에서 OSI 7계층 모델은 [그림 11-1]과 같이 TCP/IP를 기반으로 구현
- 운영체제의 내부에 포함되는 계층 4 프로토콜에는 연결형 서비스의 TCP와 비연결형 서비스의 UDP가 있음
- 네트워크 응용 프로그램에서는 시스템 콜을 사용해 TCP와 UDP 프로토콜을 실행하여 네트워크에 연결된 호스트 사이의 데이터 전송 기능을 수행
- 상위 세 계층인 세션 계층, 표현 계층, 응용 계층은 사용자 프로그램으로 구현되는데, 일반저긍로 세 계층의 기능이 하나의 프로그램으로 묶여 구현
- 상위 3개의 계층이 통합된 네트워크 응용 프로그램은 응용 환경의 요구 조건에 따라 복잡도가 달라짐

## 세션 계층
### > 세션 계층의 기능
- 세션 계층의 프로토콜이 상위 계층이 제공하는 기능
  - 세션 연결의 설정과 해제, 세션 메시지 전송 등
  - [그림 11-2]는 세션 연결과 계층 4 연결의 차이를 설명
  ![image](https://user-images.githubusercontent.com/85292541/206723073-4219b099-ffbf-47ac-bf46-ecce78221e89.png)
  - 세션 계층에서 제공하는 가장 중요한 기능은 동기 문제를 처리하는 것
  - 동기 기능은 통신 양단에서 서로 동의하는 논리적인 공통 처리 지점, 즉 동기점을 지정하기 위해 사용
  - 동기점을 설정하는 이유는 메시지 전송 과정에서 발생하는 오류를 복구하기 위함
  ![image](https://user-images.githubusercontent.com/85292541/206723817-e09ca116-72dc-49a4-a1ba-908904cb8619.png)

## 토큰
### > 토큰 종류
- 데이터 토큰 : 데이터를 전송할 수 있는 권리를 제공
- 해제 토큰 : 통신 양단 간의 연결해제 과정을 제어하기 위해 사용
- 동기 토큰 : 세션 연결을 사용하는 과정에서 동기 처리가 필요한 지점에 사용
### > 토큰과 동기점
- **논리적으로 큰 파일을 작은 단위로 나누는 과정 = 동기점을 부여하는 것**
  - 큰 파일을 물리적으로 나누지 않고 파일을 전송하는 중간중간에 동기점을 부여함으로써, 송수신 프로세스가 해당 위치까지는 데이터 전송이 완료되었다는 것에 합의할 수 있음
- **동기점을 부여하기 위한 동기 토큰**
  - 주동기 토큰 혹은 액티비티 토큰
  - 부동기 토큰

## 동기 
### > 재동기 기능
- 동기점은 데이터를 전송할 때 특정 지점에서 복구할 수 있도록 통신 양단 간의 합의로 지정
- 세션 계층의 상위 계층에는 적절한 구간으로 나뉜 지점에 동기점을 부여하고, 오류가 발생하면 해당 지점으로 돌아가 복구하는 기능이 구현되어야 함
- 이때 동기점을 이용한 일련의 복구 과정이 재동기
  - [그림 11-3]처럼 동기점은 주동기점과 부동기점으로 나뉘고, 주동기점간의 전송 단위는 대화로 정의
  
  ![image](https://user-images.githubusercontent.com/85292541/206725184-af7094f1-823c-4221-8fb5-0630962da293.png)
### > 액티비티 기능
- 액티비티는 세션 프로세스 사이에 논리적으로 설정되는 단위이며, 여러 파일들을 구분하는 목적으로 사용되고 내용이 상호 독립적
- 액티비티 단위의 시작과 끝의 표시는 주동기점의 설정과 동일한 효과를 나타냄

## 세션 연결
### > 다중 세션 연결을 지원하는 서버
- 임의의 네트워크 서비스를 제공하는 서버 프로세스가 다수의 클라이언트 프로세스에 동시에 여러 세션 연결을 설정할 수 있음
- 클라이언트 프로세스와 설정된 개별 세션들은 논리적으로 서로 연관이 없는 독립적인 연결

![image](https://user-images.githubusercontent.com/85292541/206725853-46da8395-a95b-4943-8c70-b72ea0d995fa.png)

### > 단일 세션 연결을 지원하는 서버
- 다중 세션 연결 방식의 문제를 해결하려면 서버 프로세스 하나가 클라이언트 프로세스 하나와 세션 연결을 설정해 통신해야 함
- 이런 경우에 여러 클라이언트를 동시에 지원하려면 [그림 11-5]와 같이 복사된 하위 서버 프로세스를 여러 개 만들어야 함\
![image](https://user-images.githubusercontent.com/85292541/206726426-b9254784-6574-473c-98e5-4b1850098167.png)

## 표현 계층
![image](https://user-images.githubusercontent.com/85292541/206726593-c98462c9-9abe-44b8-a2b6-1c8ec805cad3.png)
## 데이터 표현
### > 추상 문법
- 컴퓨터에서 사용하는 데이터 표현 규칙인 추상 문법으로 표현된 의미를 올바르게 송수신하려면 메시지를 전송하기 전에 변환해야 함
  - 특정 호스트에 독립적이면서 네트워크 전체에서 일관성 있는 새로운 표현 규칙인 전송 문법으로 변환하여 전송
  
       ![image](https://user-images.githubusercontent.com/85292541/206727463-fa1f4c35-554e-4568-8f69-ead11e8f0563.png)
### > ASN.1
- ISO는 분산 환경에서 표현되는 데이터를 정의하기 위한 일반적인 추상 문법으로 ASN.1을 정의
- ASN.1은 응용 환경에서 폭넓게 사용
- [그림 11-7]과 같이 PASCAL, C 언어용 코드를 생성하는 ASN.1 컴파일러도 존재
        ![image](https://user-images.githubusercontent.com/85292541/206727882-bcd5ae9d-a619-49ef-b255-5aa629b8994c.png)
- ASN.1 규약에서는 네 가지 유형의 클래스 지원
- (표) ASN.1 규약에서 지원하는 클래스 유형

|유형|설명|
|:--|:--|
|UNIVERSAL|일반 데이터형|
|CONTEXT-SPECIFIC|특정 컨텍스트(Context)와 관련된 유형|
|APPLICATION|응용 개체의 공통 유형|
|PRIVATE|사용자 정의 유형|

### > ASN.1의 UNIVERSAL 클래스
- UNIVERSAL 클래스는 일반 데이터형을 정의하며 기본형과 구조형으로 나뉨
  - 기본형
    - BOOLEAN, INTEGER 등의 단위형과 단위형의 연속적인 배열인 연속형으로 구성
    - NULL은 변수형을 정의하지 않은 경우에 사용되며, ANY는 변수형이 다른곳에서 정되는 경우에 사용
    
![image](https://user-images.githubusercontent.com/85292541/206729770-03c58193-a254-4680-8442-0b0f2d0c2415.png)
  - 구조형
    - 기본형이나 다른 구조형을 하나 이상 조합해 정의
    - 키워드를 사용해 표현
    
![image](https://user-images.githubusercontent.com/85292541/206730161-9fbb6793-a136-463c-9564-ee18d357f987.png)

### > ASN.1의 태그
- 구조형에 선언된 변수를 개별적으로 사용하려고 태깅 기능을 지원
- 태깅 기능을 사용혀려면 각 변수에 태그를 부여해야 하는데, 이는 일반 프로그래밍 언어의 배열에서 사용하는 인덱스와 기능이 유사
- 태그는 다음 세 가지 방법으로 선언
  - CONTEXT-SPECIFIC : 태그의 범위가 현재 구조형에 한정되어 적용됨
  - APPLICATION : 태그의 범위가 전체 응용 컨텍스트에 적용됨
  - PRIVATE : 태그의 범위가 해당 사용자에게 적용됨
    - 태그 사용의 예

![image](https://user-images.githubusercontent.com/85292541/206733126-ab229667-a50e-402f-b868-b1e7ef83f036.png)

## 데이터 표현
### > 데이터 압축과 보안
- 표현 계층에서 다루는 기능에는 전송되는 데이터의 양과 관련된 부분이 있음
- 전송 데이터 양이 많으면 그대로 송신하는 것보다 원래 의미를 유지하는 범위 내에서 크기를 줄이는 것이 효율적
  - 표현 계층은 이를 위해 압축 기능을 수행
- 인터넷 보안과 관련하여 중요하게 다루어지는 암호화 기능도 표현 계층에 속함
  - 암호화는 데이터를 송수신하는 당사자 외의 제3자에게 부당하게 정보가 유출되거나 왜곡되는 현상을 방지
- 네트워크 사용자에게 전송되는 데이터의 신뢰성과 함께 전송 속도도 중요한 고려 사항
- 대용량 데이터는 압축하여 크기를 줄인 후 전송하는 것이 전송 속도 면에서 유리
- 동일한 데이터에 어떤 알고리즘을 적용하느냐에 따라 압축률이 달라짐
- 일반적으로 가장 좋은 압축 알고리즘이란 없으며, 데이터의 특성에 맞는 알고리즘을 사용하는 것이 중요

### > 연속 문자 압축
- [그림 11-8]의 (a)는 T라는 문자를 모자이크 형태로 형상화한 정지 영상 데이터
- 가로 18바이트, 세로 10바이트 크기의 도화지에 X와 O 문자를 사용해 T 문자를 그림 형식으로 표현
- 이 데이터를 압축 없이 전송하면 단순한 산출 계산으로도 180바이트의 데이터를 전송해야함
- 특정 문자가 몇 번 반독된다는 표현 기법을 사용하여 압축하면, 원래의 의미를 유지하면서 데이터 크기를 줄일 수 있음
![image](https://user-images.githubusercontent.com/85292541/206753248-9d54517f-a46f-445c-94fe-6126244ffa34.png)
  - 데이터를 압축하는 알고리즘은 다음과 같이 간단한 방식으로 구현
  ![image](https://user-images.githubusercontent.com/85292541/206753684-2e0b6c69-fe05-4faf-bfa5-c7b3bfb03e25.png)
  
  - [그림 11-8]의 (b)와 같은 압축 데이터를 이용해 (a)와 같은 원본 데이터를 얻는 과정을 압축 해제라고 함 

## 데이터 압축
### > 손실,비손실 데이터 압축
- 데이터를 압축하는 유형
  - 비손실 압축, 손실 압축
- **비손실 압축**
  - 압축 과정에서 원래 데이터의 내용을 분실하지 않음 즉, 압축 해제를 통해 얻은 데이터가 압축 이전의 데이터와 완전히 동일
  - [그림 11-9]의 (b)처럼 비손실 압축 알고리즘을 사용해 압축 데이터를 복원하면 원래 데이터를 얻을 수 있음
  ![image](https://user-images.githubusercontent.com/85292541/206754463-3f8b2ee9-f6d6-492b-9572-ff8b24e921e0.png)
- **손실 압축**
  - 압축 해제한 데이터가 원래 데이터와 동일하지 않음
  - 데이터 손실 정도는 응용 환경에 따라 허용 범위가 다름
  - [그림11-9]의 (a)처럼 손실 압축 과정을 거친 압축 데이터는 압축 해제가 되었을 때, 원래 데이터를 완전히 복원할 수 없음
  - 손실 압축을 사용하는 이유는 비손실 압축에 비하여 압축 데이터의 크기가 작기 때문
    - 네트워크로 전송되는 데이터 양도 줄게 되어 전송 효율을 높일 수 있음
 
## 응용 계층
### > 클라이언트 서버 모델
- 클라이언트와 서버는 [그림 11-10]과 같이 비교적 간단한 절차로 동작
 ![image](https://user-images.githubusercontent.com/85292541/206756284-cfa5fa62-eb97-4ccb-9575-2d5669f60d46.png)

- 일반적으로 서버 프로세스는 클라이언트보다 먼저 실행되어 대기 상태에 있기 때문에 클라이언트의 연결 요청에 항상 응답할 수 있음
- 서버 프로세스는 일단 시작되면 영원히 종료되지 않고 실행되며, 다수의 클라이언트 요청을 반복적으로 수행

### > 연결형,비연결형 서비스
- 클라이언트·서버 모델을 구현할 때 먼저 고려할 사항은 비연결형과 연결형 중에서 어떤 연결 방식을 사용할지를 결정하는 것
- UDP에서 제공하는 비연결형 서비스는 빠른 통신을 보장하지만, 데이터 분실이나 비순서 도착이라는 단점 때문에 응용 프로그래머의 부담이 큼
- 반면 TCP가 제공하는 연결형 서비스는 신뢰성이 높지만 UDP보다 속도가 떨어짐
- UDP는 연결 설정에 따른 클라이언트와 서버 사이의 상태 문제를 해결하기 곤란한 응용 환경에서 주로 사용
- 특정한 사유로 연결이 끊기면 TCP 프로토콜은 이전 상태를 복구하는 절차가 복잡하지만, 상대적으로 UDP는 복구 절차가 간단

### > 상태 정보
- 연결형 서비스는 클라이언트와 서버 사이의 연결로 인해 둘 사이의 현재 상태라는 개념이 존재
- 기타 정보는 내부적으로 클라이언트와 서버가 논리적으로 하나의 단위로 처리해야 하는 동작을 한순간에 처리하지 못하고 여러 단계로 나누어 처리하는 경우에 발생
- 상태 정보는 정상적으로 처리될 때는 문제 없지만, 한쪽 시스템이 다운되는 등의 현상에 의해 상태 정보를 잃어버렸을 때는 다운되기 직전 상태로 복구해야하는 문제가 발생
- 클라이언트에 원격 파일 서비스를 제공하는 파일 서버는 비상태서비스의 대표적인 예
- 원격 파일 서비스를 상태 서비스로 구현하는 경우는 이전 절차에서 수신한 정보가 서버가 내부적으로 보관하는 경우


